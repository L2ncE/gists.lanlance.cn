## 场景

### 1. 强制用户下线，让其无法再次登录怎么设计？

在用户表中增加一个状态字段，例如：status，其值为 1 时代表账号正常，其值为 0 时代表账号已被封禁。当需要强制注销一个用户时，只需要将其账号的
status 值修改为 0 即可，对方再次登录系统时，系统便可以检测到 status 值不为 1 禁止登录 1。

### 2. 多个客户端单一账号怎么禁止登录？

要禁止同一账号在多个客户端登录，可以监视每一个连接的用户账号，如果发现一个新连接的用户账号跟某个已经存在的连接的用户账号相同，则自动将前一个终止（同样，也可以让用户自己决定终止哪一个）。在 web 应用系统中，出于安全性考虑，经常需要对同一客户端登录的用户数量和一个客户同时在多个客户端登陆进行限制。具体一点就是：

1. 在同一台电脑上一次只允许有一个用户登录系统
2. 一个用户在同一时间只允许在一个客户端登录

### 3. 限流器的设计

#### 固定窗口

利用 redis 的原子自增和过期淘汰策略

  - 限流器的计数存放在 redis 中，用 redis 的过期淘汰策略实现限流器的计数的定期更新 

  - 例如针对 接口 A 限流 10000 QPS。redis 的 key 为：“接口 A”，value 为计数值 - 每次接口调用 Redis 用 INC 原子自增命令，自增 1，并设置过期时间为 1s 

  - 初次调用时，因为 redis 中该 key 没有，就直接设置为 1，并设置过期时间为 1s

  - 在这一秒以内的后续调用，每次都自增 1 - 客户端拿到自增后的值如果没有超过限制 10000，就放行 - 如果超过 10000 限制，就不放行，说明超限了

  - 细节实现：为避免超限后无谓的 redis 调用，第一次发现超限时可以记录该值的 TTL 时间，例如只过去 100ms 就有 1w 个请求过来，剩下的 900ms 就不用请求 redis 而是直接返回超限即可。不然这种情况会给 redis 带去额外无谓的流量，例如前面的例子，不做这个细节逻辑的话，redis 的请求量是 10w QPS

  - 精度可调节。假如限流阈值很大，比如 100w，可以把 INC 自增步进/步长调整大一些，例如 100，那么 redis 的 QPS 直接降低 100 倍，为 1w QPS

这样是一个固定窗口的限流器，不能应对突刺情况，可以增加滑动窗口的设计或者使用令牌桶方法。

#### 优化

- 滑动窗口

你可以使用 Redis 提供的有序集合（sorted set）数据结构来存储每一次请求的时间戳，用 score 来表示请求的时间。每次来新的请求，都添加到有序集合中。然后，根据当前的时间戳，删除窗口之外的请求记录，并查看当前窗口内的请求数量是否超过阈值。

- 令牌桶

可以设定每秒钟往桶中放入 100 个令牌，如果有新的请求进来，就从桶中拿走一个令牌，如果桶中没有令牌了，新的请求就需要等待或者被丢弃，这样就可以保护系统不会被突然的大流量压垮。

#### 超高 QPS 优化

使用固定步长 + 本地缓存，每次 Redis 按步长取令牌到本地缓存，本地令牌消耗完后再到 Redis 中进行获取，大幅减少 Redis 压力。如果是突发的高 QPS 流量可以通过动态步长进行实现。
